/*
 * Atoll (DynamicIsland)
 * Copyright (C) 2024-2026 Atoll Contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

import AppKit
import SwiftUI

struct IceHiddenItemsView: View {
    @EnvironmentObject var itemManager: MenuBarItemManager
    @EnvironmentObject var imageCache: MenuBarItemImageCache
    @EnvironmentObject var vm: DynamicIslandViewModel
    @State private var lastKnownItems = [MenuBarItem]()
    @State private var isRecoveringExpectedHidden = false
    @State private var lastRecoveryTriggerDate = Date.distantPast
    private let refreshTimer = Timer.publish(every: 2, on: .main, in: .common).autoconnect()
    private let recoveryTriggerInterval: TimeInterval = 1
    
    var items: [MenuBarItem] {
        itemManager.itemCache.managedItems(for: .hidden)
    }

    var displayedItems: [MenuBarItem] {
        items.isEmpty ? lastKnownItems : items
    }

    private var appState: AppState {
        AppDelegate.iceAppState
    }

    private var isFullscreenBlackMenuBar: Bool {
        appState.isActiveSpaceFullscreen && appState.menuBarManager.isMenuBarHiddenBySystem
    }

    private func triggerExpectedHiddenRecoveryIfNeeded() {
        guard vm.notchState == .open else { return }
        guard vm.isHoveringIceMenu else { return }
        guard !isFullscreenBlackMenuBar else { return }
        guard !isRecoveringExpectedHidden else { return }
        guard Date.now.timeIntervalSince(lastRecoveryTriggerDate) >= recoveryTriggerInterval else { return }

        lastRecoveryTriggerDate = .now

        Task {
            guard await itemManager.hasExpectedHiddenMismatch() else {
                return
            }

            await MainActor.run {
                isRecoveringExpectedHidden = true
            }

            let didRecover = await itemManager.recoverExpectedHiddenItemsToPolicy()

            await itemManager.cacheItemsIfNeeded()
            if ScreenCapture.cachedCheckPermissions() {
                await imageCache.updateCacheWithoutChecks(sections: [.hidden])
            }

            await MainActor.run {
                isRecoveringExpectedHidden = false
                if didRecover, vm.notchState == .open {
                    withAnimation(.smooth) {
                        vm.close()
                    }
                }
            }
        }
    }
    
    var body: some View {
        Group {
            if displayedItems.isEmpty {
                EmptyView()
                    .onAppear {
                        Task {
                            await itemManager.cacheItemsIfNeeded()
                        }
                    }
            } else if isRecoveringExpectedHidden {
                HStack(spacing: 8) {
                    ProgressView()
                        .controlSize(.small)
                    Text("Recovering hidden itemsâ€¦")
                        .font(.caption)
                        .foregroundStyle(.white.opacity(0.75))
                }
                .frame(height: 32)
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 8) {
                        ForEach(displayedItems, id: \.windowID) { item in
                            IceHiddenItemView(item: item)
                        }
                    }
                    .padding(.horizontal, 8)
                }
                .frame(height: 32)
                .simultaneousGesture(
                    DragGesture(minimumDistance: 6)
                        .onChanged { _ in
                            triggerExpectedHiddenRecoveryIfNeeded()
                        }
                )
                .contextMenu {
                    Button("Open Ice Settings") {
                        AppDelegate.iceAppState.openSettingsWindow()
                    }
                    Button("Recover Hidden Items") {
                        Task {
                            await itemManager.recoverTempShownItemsToHiddenSection()
                            await itemManager.cacheItemsIfNeeded()
                            if ScreenCapture.cachedCheckPermissions() {
                                await imageCache.updateCacheWithoutChecks(sections: [.hidden])
                            }
                        }
                    }
                }
                .onAppear {
                    Task {
                        await itemManager.cacheItemsIfNeeded()
                    }
                }
            }
        }
        .allowsHitTesting(!isFullscreenBlackMenuBar && !isRecoveringExpectedHidden)
        .onChange(of: isFullscreenBlackMenuBar) { _, isBlocked in
            if isBlocked {
                vm.isHoveringIceMenu = false
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: NSScrollView.didLiveScrollNotification)) { _ in
            triggerExpectedHiddenRecoveryIfNeeded()
        }
        .onReceive(refreshTimer) { _ in
            guard vm.notchState == .open else { return }
            guard !isRecoveringExpectedHidden else { return }
            Task {
                await itemManager.cacheItemsIfNeeded()
                if ScreenCapture.cachedCheckPermissions() {
                    await imageCache.updateCacheWithoutChecks(sections: [.hidden])
                }
                await MainActor.run {
                    if !items.isEmpty {
                        lastKnownItems = items
                    }
                }
            }
        }
        .onChange(of: items.map(\.windowID)) { _, newWindowIDs in
            guard !newWindowIDs.isEmpty else { return }
            lastKnownItems = items
        }
    }
}

struct IceHiddenItemView: View {
    @EnvironmentObject var imageCache: MenuBarItemImageCache
    @EnvironmentObject var itemManager: MenuBarItemManager
    @EnvironmentObject var vm: DynamicIslandViewModel
    
    let item: MenuBarItem

    private func waitForMenuWindowOpen(ownerPID: pid_t, baselineWindowIDs: Set<CGWindowID>) async {
        MouseCursor.hide()
        defer { MouseCursor.show() }

        let popupLevel = Int(CGWindowLevelForKey(.popUpMenuWindow))
        let timeout = Date.now.addingTimeInterval(0.8)

        while Date.now < timeout {
            let windows = WindowInfo.getOnScreenWindows(excludeDesktopWindows: true)
            let didOpenMenu = windows.contains { window in
                window.ownerPID == ownerPID &&
                window.isOnScreen &&
                (
                    !baselineWindowIDs.contains(window.windowID) ||
                    window.layer == popupLevel
                ) &&
                window.layer != kCGStatusWindowLevel
            }

            if didOpenMenu {
                return
            }

            try? await Task.sleep(for: .milliseconds(25))
        }
    }
    
    private var image: NSImage? {
        guard let image = imageCache.images[item.info],
              let screen = imageCache.screen else {
            return nil
        }
        let size = CGSize(
            width: CGFloat(image.width) / screen.backingScaleFactor,
            height: CGFloat(image.height) / screen.backingScaleFactor
        )
        return NSImage(cgImage: image, size: size)
    }
    
    var body: some View {
        if let image {
            Button {
                triggerClick(.left)
            } label: {
                Image(nsImage: image)
            }
            .buttonStyle(.plain)
            .contentShape(Rectangle())
            .contextMenu {
                Button("Open Menu Item") {
                    triggerClick(.left)
                }
                Button("Right Click Menu Item") {
                    triggerClick(.right)
                }
                Divider()
                Button("Open Ice Settings") {
                    AppDelegate.iceAppState.openSettingsWindow()
                }
                Button("Recover Hidden Items") {
                    Task {
                        await itemManager.recoverTempShownItemsToHiddenSection()
                    }
                }
            }
            .help(item.displayName)
        } else {
            Button {
                triggerClick(.left)
            } label: {
                Image(systemName: "app.badge")
                    .font(.system(size: 13, weight: .semibold))
                    .foregroundStyle(.white.opacity(0.85))
                    .frame(width: 18, height: 18)
            }
            .buttonStyle(.plain)
            .contentShape(Rectangle())
            .contextMenu {
                Button("Open Menu Item") {
                    triggerClick(.left)
                }
                Button("Right Click Menu Item") {
                    triggerClick(.right)
                }
                Divider()
                Button("Open Ice Settings") {
                    AppDelegate.iceAppState.openSettingsWindow()
                }
                Button("Recover Hidden Items") {
                    Task {
                        await itemManager.recoverTempShownItemsToHiddenSection()
                    }
                }
            }
            .help(item.displayName)
        }
    }

    private func triggerClick(_ mouseButton: CGMouseButton) {
        Task {
            let buttonName = mouseButton == .left ? "left" : "right"
            NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click item=\(item.logString) windowID=\(item.windowID)")
            try? await Task.sleep(for: .milliseconds(120))
            await MainActor.run {
                if vm.notchState == .open {
                    NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click collapsing notch before item trigger")
                    withAnimation(.smooth) {
                        vm.close()
                    }
                }
            }
            try? await Task.sleep(for: .milliseconds(220))
            await itemManager.cacheItemsIfNeeded()
            if ScreenCapture.cachedCheckPermissions() {
                await imageCache.updateCacheWithoutChecks(sections: [.hidden])
            }
            try? await Task.sleep(for: .milliseconds(25))
            let resolvedItem = await MainActor.run {
                let hiddenItems = itemManager.itemCache.managedItems(for: .hidden)
                return hiddenItems.first {
                    $0.windowID == item.windowID ||
                    $0.info == item.info ||
                    ($0.ownerPID == item.ownerPID && $0.title == item.title)
                } ?? MenuBarItem(windowID: item.windowID) ?? item
            }
            NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click resolved item=\(resolvedItem.logString) windowID=\(resolvedItem.windowID)")
            if resolvedItem.isOnScreen {
                do {
                    NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click direct item click windowID=\(resolvedItem.windowID)")
                    let baselineWindowIDs = Set(
                        WindowInfo.getOnScreenWindows(excludeDesktopWindows: true)
                            .filter { $0.ownerPID == resolvedItem.ownerPID }
                            .map(\.windowID)
                    )
                    try await itemManager.click(item: resolvedItem, with: mouseButton)
                    await waitForMenuWindowOpen(ownerPID: resolvedItem.ownerPID, baselineWindowIDs: baselineWindowIDs)
                } catch {
                    let latestResolved = MenuBarItem(windowID: resolvedItem.windowID) ?? resolvedItem
                    if latestResolved.isOnScreen {
                        NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click direct failed but item remained onscreen; skipping outer fallback")
                        return
                    }
                    NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click direct failed; fallback tempShowItem windowID=\(resolvedItem.windowID)")
                    itemManager.tempShowItem(resolvedItem, clickWhenFinished: true, mouseButton: mouseButton)
                }
            } else {
                NSLog("ðŸ”Ž IceHiddenItemsView \(buttonName) click using tempShowItem windowID=\(resolvedItem.windowID)")
                itemManager.tempShowItem(resolvedItem, clickWhenFinished: true, mouseButton: mouseButton)
            }
        }
    }
}
